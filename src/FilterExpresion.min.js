class FilterExpression { constructor(t = LogicalOperator.And) { this.filterOperator = t, this.expressionArray = [] } addCondition(t, r, e) { return this.expressionArray.push(new ConditionExpression(t, r, e).getCondition()), this } addFilter(t) { return this.expressionArray.push(t.retrieveFetchXml()), this } retrieveFetchXml() { return `<filter type="${this.filterOperator}">${this.expressionArray.join("")}</filter>` } } class ConditionExpression { constructor(t, r, e) { this.attribute = t, this.operator = r, this.value = e } getCondition() { return void 0 === this.value ? `<condition attribute="${this.attribute}" operator="${this.operator}"/>` : Array.isArray(this.value) ? this.value.map(t => `<condition attribute="${this.attribute}" operator="${this.operator}" value="${t}" />`).join("") : `<condition attribute="${this.attribute}" operator="${this.operator}" value="${this.value}" />` } } const LogicalOperator = { Or: "or", And: "and" }; Object.freeze(LogicalOperator); const ConditionOperator = { Equal: "eq", Null: "null", NotEqual: "ne", LessThan: "lt", LessEqual: "le", GreaterThan: "gt", GreaterEqual: "ge", NotNull: "not-null" }; Object.freeze(ConditionalOperator);